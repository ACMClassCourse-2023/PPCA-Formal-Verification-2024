# 项目选题

在介绍项目选题之前，我们先来回顾一下形式化验证算法的基本流程：

- **定义问题**。我们需要将 informal 的使用自然语言描述的问题合理地形式化，这包括问题的背景和一个问题的解应具有什么性质 (即 specification) 等。这并没有绝对的标准，但形式化的概念之间的关系应与直觉相符，不同的合理的 spec 应该是等价的。

- **描述算法**。这和平时写程序做算法题类似，但在 coq 中不同之处是我们需要用纯函数式程序而非我们熟悉的命令式程序描述算法，最终得到一个对应算法的函数。在没有循环以及数组的情况下，利用算法中的递归结构很重要。

- **证明算法的正确性**。在前两步的基础上，我们需要证明我们描述的算法是对我们定义的问题的正确解答，即符合我们描述的 spec。

关于算法的描述：在更广泛的意义下，我们可以用不同的粒度描述算法，用输入输出的关系而非函数来描述一些步骤，例如定义 `` split l_pre l1 l2`` 来描述将 list 均分为两半的过程而非直接给出具体的分离函数。这在描述算法的结构和验证 C 程序时有重要作用，但具有不可直接计算的缺点 (这样形式化的算法本身并不是可以运行的程序) 。在本项目中你描述的算法应该是一个在 coq 中可以直接计算的函数。

下面我们将介绍三个项目选题，每一个选题都需要完成上述三步并在 coq 中通过验证。你只需要证明其正确性，不需要证明其时间复杂度。

## Maximum Segment Sum
这是一道广为人知的经典算法题：给出一个长度为 $n$ 的整数序列 $a$，选出其中连续且非空的一段使得这段和最大。描述一个 $O(n)$ 时间内解决这个问题的算法并证明其正确性。

## Majority Element
一个列表 $l$ 有 majority element $M$ 是指 $l$ 中有超过一半的元素都是 $M$。空列表不具有 majority element。需要注意 $l$ 的元素之间只能比较是否相同，不保证具有序关系。描述一个算法，输入列表 $l$，在 $O(n)$ ($l$ 长度为 $n$) 时间内判断 $l$ 是否有 majority element $M$，若有则输出 $M$ ，并证明其正确性。

- 你的算法应该需要一个类型参数 ``A: Type`` 来描述抽象的列表元素。

- 考虑将 $l$ 的元素任意两两配对，对每一对元素，若不同则舍弃，相同则只保留一个。

## Dating Schedule
Dark 在同一天收到了多位女生的约会邀请，每个女生的约会有固定的开始时间 $l_i$ 和结束时间 $r_i$，$l_i$, $r_i$都是非负整数且$r_i > l_i$。Dark 想和尽量多的女生约会，但只要 Dark 和一个女生约会，他就不能和其他约会时间和这个女生有重合的女生约会，但允许“无缝衔接”。例如，他可以和约会时间为 $[1, 3]$ 和 $[3,5]$ 的女生都约会，但不能和约会时间为 $[1, 3]$ 和 $[2,5]$ 的女生都约会。输入一个元素为$[l_i, r_i]$ 的列表，可以假设其按 $l_i$ 或 $r_i$ 或 $r_i - l_i$ 的递增顺序排序，描述一个算法，在 $O(n)$ ($n$ 为列表长度) 时间内输出 Dark 在同一天最多能和多少女生约会，并证明其正确性。

- 这是一个贪心算法，你可以根据你的算法指定输入列表的顺序，并将其形式化在问题的定义中。

- 这个算法很简单，证明比较复杂。

- 贪心算法正确性证明往往依赖归纳法：找到适合递推的归纳命题很关键。